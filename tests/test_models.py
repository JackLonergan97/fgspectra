
from fgspectra import cross as fgc
from fgspectra import power as fgp
from fgspectra import frequency as fgf
import numpy as np


def test_ACT_models():
    # define the models from fgspectra
    tsz = fgc.FactorizedCrossSpectrum(fgf.ThermalSZ(), fgp.tSZ_150_bat())
    ksz = fgc.FactorizedCrossSpectrum(fgf.UnitSED(), fgp.kSZ_bat())
    cibp = fgc.FactorizedCrossSpectrum(fgf.CIB(), fgp.PowerLaw())
    cibc = fgc.FactorizedCrossSpectrum(fgf.CIB(), fgp.PowerLaw())
    tSZxCIB = fgc.FactorizedCrossSpectrum(
        fgf.tSZxCIB(effective_frequencies=True), fgp.sz_x_cib_template())
    radio = fgc.FactorizedCrossSpectrum(fgf.PowerLaw_g(), fgp.PowerLaw())
    cirrus = fgc.FactorizedCrossSpectrum(fgf.PowerLaw_g(), fgp.PowerLaw())

    ells = np.array([2000])


    par = {
        'nu_0' : 150.0,
        'ell_0' : 3000,
        'T_CMB' : 2.725,
        'T_d' : 9.7,

        'a_tSZ' : 4.66,
        'a_kSZ' : 1.60,
        'a_p' : 6.87,
        'beta_p' : 2.08,
        'a_c' : 6.10,
        'beta_c' : 2.08,
        'n_CIBC' : 1.20,
        'xi' : 0.09,
        'a_s' :3.50,
        'a_g' :0.88,

        'f0_sz' : 146.9,
        'f0_synch'  :147.6,
        'f0_dust'   :149.7
    }

    fsz = np.array([par['f0_sz']])
    fsynch = np.array([par['f0_synch']])
    fdust = np.array([par['f0_dust']])

    result = (
            par['a_tSZ'] * tsz(
                [fsz, par['nu_0'], par['T_CMB']], [ells])[0][0][0],
            par['a_kSZ'] * ksz(
                [fsz], [ells])[0][0][0],
            par['a_p'] * cibp(
                [fdust, par['beta_p'], par['T_d'],par['nu_0']],
                [ells, 2, par['ell_0']])[0][0][0] ,
            par['a_c'] * cibc(
                [fdust, par['beta_c'], par['T_d'], par['nu_0']],
                [ells, 2-par['n_CIBC'], par['ell_0']])[0][0][0] ,
            (-2*par['xi'] * np.sqrt(par['a_tSZ'] * par['a_c'])) * tSZxCIB(
                [fsz, fdust, par['beta_c'], par['nu_0']], [ells])[0][0][0][0] ,
            par['a_s'] * radio(
                [fsynch, -0.5, par['nu_0'], par['T_CMB']],
                [ells, 2, par['ell_0']])[0][0][0] ,
            par['a_g'] * cirrus(
                [fdust, 3.8, par['nu_0'], par['T_CMB']],
                [ells, -0.7, par['ell_0']])[0][0][0])

    """
    The following array `dunk13` was generated by inserting this code block to
    line 188 of `ACT_equa_likelihood.f90` in the Fortran ACT multifrequency
    likelihood.

    ```fortran
    if(il==2000) then
      write(*,*) (f1*f1)/(f0*f0)*amp_tsz*cl_tsz(il)
      write(*,*) amp_ksz*cl_ksz(il)
      write(*,*) amp_d*cl_p(il)*(f1_dust/feff)**(2.d0*beta_d)*(planckratiod1*fluxtempd1)**2.d0
      write(*,*) amp_c*cl_c(il)*(f1_dust/feff)**(2.d0*beta_c)*(planckratiod1*fluxtempd1)**2.d0
      write(*,*) -2.d0*sqrt(amp_c*amp_tsz)*xi*cl_szcib(il)*((f1_dust**beta_c*f1*planckratiod1*fluxtempd1)/(feff**beta_c*f0))
      write(*,*) amp_s*cl_p(il)*(f1_synch/feff)**(2.d0*alpha_s)*fluxtemps1**2.d0
      write(*,*) amp_ge*cl_cir(il)*(f1_dust**2.d0/feff**2.d0)**beta_g*fluxtempd1**2.d0
    endif
    ```
    """
    dunk13 = np.array( [
        4.46395567509345,
        1.37903889069153,
        3.02039291213271,
        4.36478789541715,
        -0.611930900267790,
        1.63099887443075,
        1.15557760337592] )
    # print(np.abs(result-dunk13) / result)
    assert ( np.max( np.abs(result-dunk13) / result ) < 1e-3 )
